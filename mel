#!/bin/sh -u
#
# Copyright (c) 2019, Cristian Ariza
# All rights reserved.
#
# Ed-like text editor in POSIX shell

###########
# Functions
###########

add() {
	n="$1" && shift
	text="$1" && shift

	swp="$(cat "$@")"

	case "x$n" in
	x-a)
		if [ -z "$swp" ]; then
			printf '%s\n' "$text"
		else
			printf '%s\n%s\n' "$swp" "$text"
		fi
		;;
	x0)
		printf '%s\n%s' "$text" "$swp"
		;;
	*)
		printf '%s' "$swp" | sed -n 1,"$n"p
		printf '%s\n' "$text"
		printf '%s' "$swp" | sed -n "$((n + 1))",\$p
		;;
	esac
}

_print() {
	if [ "$#" -eq 0 ]; then
		i=1
		while read -r line; do
			printf '%s | %s\n' "$i" "$line"
			i=$((i + 1))
		done <"$SWAP"
		echo 'EOF'
	elif [ "$1" = "-a" ]; then
		tail -n 1 "$SWAP"
	else
		echo 'here'
		sed -n "$1"p "$SWAP"
	fi
}

change() { add "$@" | sed "$1"d; }

# Processes user commands
meleval() {
	cmd="$1" && shift
	case "$cmd" in
	a | c)
		if [ "$#" -gt 0 ]; then
			n="$1" && shift
		fi

		case "$cmd" in
		c) cmd="change" ;;
		*) cmd="add" ;;
		esac

		# If n is empty or unset, use -a as its value.
		_print "${n:--a}"
		cat "$SWAP" >"$BKP"
		"$cmd" "${n:--a}" "$(cat)" "$BKP" >"$SWAP"
		;;
	d) sed -i "$1"d "$SWAP" ;; # Deletes a line
	*e)
		# Edit another file
		mv "$SWAP" "$BKP"
		exec "$0" "$@"
		;;
	*w | *wq) cat "$SWAP" >"$ORIG" ;; # Saves the file
	p) _print "$@" ;;
	u) cat "$BKP" >"$SWAP" ;; # Undoes last change
	/) grep -n "$@" "$SWAP" ;;
	*!) "$@" ;; # Shell commands
	*q | exit | quit) ;;
	*) printf "mel: the '%s' command is unknown\\n" "$cmd" ;;
	esac

	case "$cmd" in
	*q | exit | quit) exit 0 ;;
	esac
}

usage="mel v0.0.1 (C) Cristian Ariza
	
usage: $(basename "$0") [OPTIONS] [FILE]

	-H  List available features"

# Disables Ctrl+C
trap '' 2

DIR="$(
	cd "$(dirname "$0")" || exit 1
	pwd
)"
export PATH="$DIR"/../lib/mel:"$PATH"

if test "$#" -ne 1 || test "$1" = "--help" || test ! -f "$1"; then
	printf '%s\n' "$usage"
	exit 1
fi

ORIG="$1"
SWAP=."$1".melswp
BKP=."$1".melbkp
PROMPT="$(basename "$ORIG")"

cat "$ORIG" >"$SWAP"

trap 'rm "$SWAP"' EXIT

while :; do
	printf '%s> ' "$PROMPT"
	read -r input
	if test "${#input}" -eq 0; then
		continue
	fi

	eval "set -- $input"
	meleval "$@"
done
